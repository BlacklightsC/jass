"themes": [
      {
        "label": "jass",
        "path": "./src/settings/jass-color-theme.json"
      }
    ],

    aaaaaaaaaaaaa,dd   //         " //aaaaaaaaaaaaa  "
    // 
vscode.languages.registerSignatureHelpProvider(language, {
    /**
     * 
     * @param {vscode.TextDocument} document 
     * @param {vscode.Position} position 
     * @param {vscode.CancellationToken} token 
     * @param {vscode.SignatureHelpContext} context 
     * @returns {vscode.ProviderResult<vscode.SignatureHelp>}
     */
    provideSignatureHelp(document, position, token, context) {
      let sh = new vscode.SignatureHelp()
      sh.signatures = [new vscode.SignatureInformation("degrees", "hahahahaha")]
      return sh
    }
  }, "(", '  ,')


// format
for (let i = 0; i < words.length; i++) {
    let word = words[i];
    let p1 = words[i - 1]
    let p2 = words[i - 2]
    let n1 = words[i + 1]
    let n2 = words[i + 2]
    let length = word.length
    // 右边只能有一个空格
    if (word == "function" ||
      word == "takes" ||
      word == "returns" ||
      word == "native" ||
      word == "constant" ||
      word == "return" ||
      word == "if" ||
      word == "elseif" ||
      word == "exitwhen" ||
      word == "local" ||
      word == "call" ||
      word == "set" ||
      word == "type" ||
      word == "extends" ||
      word == "not" ||
      word == "and" ||
      word == "or" ||
      word == "," ||
      (word == "=" && n1 != "=") ||
      (word == ">" && n1 != "=") ||
      (word == "<" && n1 != "=") ||
      word == "+" ||
      (word == "-" && isSpace(n1)) ||
      word == "*" ||
      word == "/" ||
      word == "%" ||
      word == "mod") {
      if (isSpace(n1)) {
        if (n1.length != 1) {
          let range = new vscode.Range(line, colume + length, line, colume + length + n1.length)
          edits.push(edit.replace(range, " "))
        }
      } else {
        edits.push(edit.insert(new vscode.Position(line, colume + length), " "))
      }
    }
    // 左边只能有一个空格
    if (word == "or" ||
      word == "and" ||
      word == "not" ||
      (word == "=" && p1 != "=" && p1 != "!" && p1 != "<" && p1 != ">") ||
      (word == "!" && n1 == "=") ||
      word == ">" ||
      word == "<" ||
      word == "extends" ||
      word == "takes" ||
      word == "returns" ||
      word == "then" ||
      word == "+" ||
      (word == "-" && isSpace(n1)) ||
      word == "*" ||
      word == "/" ||
      word == "%" ||
      word == "mod") {
      if (isSpace(p1)) {
        if (p1.length != 1) {
          let range = new vscode.Range(line, colume - p1.length, line, colume)
          edits.push(edit.replace(range, " "))
        }
      } else {
        edits.push(edit.insert(new vscode.Position(line, colume), " "))
      }
    }
    // 右边不能是空格
    if (
      word == "(" ||
      word == "[") {
      if (isSpace(n1)) {
        let range = new vscode.Range(line, colume + length, line, colume + length + n1.length)
        edits.push(edit.delete(range))
      }
    }
    // 左边不能是空格
    if (
      word == ")" ||
      word == "]") {
      if (isSpace(p1)) {
        let range = new vscode.Range(line, colume - p1.length, line, colume)
        edits.push(edit.delete(range))
      }
    }
    // 右边必须是换行
    /*
     if (word == "globals" ||
     word == "endglobals" ||
     word == "endfunction" ||
     word == "then" ||
     word == "loop") {
     if (!isNewLine(n1)) {
     if (isSpace(n1) && !isNewLine(n2)) {
     edits.push(edit.insert(new vscode.Position(line, colume + length), "\n"))
     }
     }
     }
     // 左边必须是换行
     if (word == "globals" ||
     word == "endglobals" ||
     word == "endfunction") {
     if (!isNewLine(p1)) {
     if (isSpace(p1) && !isNewLine(p2)) {
     edits.push(edit.insert(new vscode.Position(line, colume), "\n"))
     }
     }
     }*/
    colume += length
    if (word == "\n") {
      line++;
      colume = 0
    }
  }

  [a-zA-Z]\\w*\\s*(?==)|[a-zA-Z]\\w*\\s*(?=\\+)|[a-zA-Z]\\w*\\s*(?=-)|[a-zA-Z]\\w*\\s*(?=\\*)|[a-zA-Z]\\w*\\s*(?=/)|[a-zA-Z]\\w*\\s*(?=%)|[a-zA-Z]\\w*\\s*(?=>)|[a-zA-Z]\\w*\\s*(?=<)|[a-zA-Z]\\w*\\s*(?=\\[)|[a-zA-Z]\\w*\\s*(?=\\])


// 變量正則
  [a-zA-Z]\\w*\\s*(?=\\!)|[a-zA-Z]\\w*\\s*(?==)|[a-zA-Z]\\w*\\s*(?=\\+)|[a-zA-Z]\\w*\\s*(?=-)|[a-zA-Z]\\w*\\s*(?=\\*)|[a-zA-Z]\\w*\\s*(?=/)|[a-zA-Z]\\w*\\s*(?=%)|[a-zA-Z]\\w*\\s*(?=>)|[a-zA-Z]\\w*\\s*(?=<)|[a-zA-Z]\\w*\\s*(?=\\[)|[a-zA-Z]\\w*\\s*(?=\\])|[a-zA-Z]\\w*\\s*(?=\\.)|[a-zA-Z]\\w*\\s*(?=,)|[a-zA-Z]\\w*\\s*(?=\\))|(?<=\\!)\\s*[a-zA-Z]\\w*|(?<=\\+)\\s*[a-zA-Z]\\w*|(?<=-)\\s*[a-zA-Z]\\w*|(?<=\\*)\\s*[a-zA-Z]\\w*|(?<=/)\\s*[a-zA-Z]\\w*|(?<=%)\\s*[a-zA-Z]\\w*|(?<=>)\\s*[a-zA-Z]\\w*|(?<=<)\\s*[a-zA-Z]\\w*|(?<=\\[)\\s*[a-zA-Z]\\w*|\\s*[a-zA-Z]\\w*(?=\\])|(?<=\\()\\s*(?!not)[a-zA-Z]\\w*|(?<=\\.)\\s*[a-zA-Z]\\w*(?!\\()

  (?<=boolean)\\s+(?!extends)[a-zA-Z]\\w*|(?<=integer)\\s+(?!extends)[a-zA-Z]\\w*|(?<=real)\\s+(?!extends)[a-zA-Z]\\w*|(?<=string)\\s+(?!extends)[a-zA-Z]\\w*|(?<=handle)\\s+(?!extends)[a-zA-Z]\\w*|(?<=code)\\s+(?!extends)[a-zA-Z]\\w*|(?<=agent)\\s+(?!extends)[a-zA-Z]\\w*|(?<=event)\\s+(?!extends)[a-zA-Z]\\w*|(?<=player)\\s+(?!extends)[a-zA-Z]\\w*|(?<=widget)\\s+(?!extends)[a-zA-Z]\\w*|(?<=unit)\\s+(?!extends)[a-zA-Z]\\w*|(?<=destructable)\\s+(?!extends)[a-zA-Z]\\w*|(?<=item)\\s+(?!extends)[a-zA-Z]\\w*|(?<=ability)\\s+(?!extends)[a-zA-Z]\\w*|(?<=buff)\\s+(?!extends)[a-zA-Z]\\w*|(?<=force)\\s+(?!extends)[a-zA-Z]\\w*|(?<=group)\\s+(?!extends)[a-zA-Z]\\w*|(?<=trigger)\\s+(?!extends)[a-zA-Z]\\w*|(?<=triggercondition)\\s+(?!extends)[a-zA-Z]\\w*|(?<=triggeraction)\\s+(?!extends)[a-zA-Z]\\w*|(?<=timer)\\s+(?!extends)[a-zA-Z]\\w*|(?<=location)\\s+(?!extends)[a-zA-Z]\\w*|(?<=region)\\s+(?!extends)[a-zA-Z]\\w*|(?<=rect)\\s+(?!extends)[a-zA-Z]\\w*|(?<=boolexpr)\\s+(?!extends)[a-zA-Z]\\w*|(?<=sound)\\s+(?!extends)[a-zA-Z]\\w*|(?<=conditionfunc)\\s+(?!extends)[a-zA-Z]\\w*|(?<=filterfunc)\\s+(?!extends)[a-zA-Z]\\w*|(?<=unitpool)\\s+(?!extends)[a-zA-Z]\\w*|(?<=itempool)\\s+(?!extends)[a-zA-Z]\\w*|(?<=race)\\s+(?!extends)[a-zA-Z]\\w*|(?<=alliancetype)\\s+(?!extends)[a-zA-Z]\\w*|(?<=racepreference)\\s+(?!extends)[a-zA-Z]\\w*|(?<=gamestate)\\s+(?!extends)[a-zA-Z]\\w*|(?<=igamestate)\\s+(?!extends)[a-zA-Z]\\w*|(?<=fgamestate)\\s+(?!extends)[a-zA-Z]\\w*|(?<=playerstate)\\s+(?!extends)[a-zA-Z]\\w*|(?<=playerscore)\\s+(?!extends)[a-zA-Z]\\w*|(?<=playergameresult)\\s+(?!extends)[a-zA-Z]\\w*|(?<=unitstate)\\s+(?!extends)[a-zA-Z]\\w*|(?<=aidifficulty)\\s+(?!extends)[a-zA-Z]\\w*|(?<=eventid)\\s+(?!extends)[a-zA-Z]\\w*|(?<=gameevent)\\s+(?!extends)[a-zA-Z]\\w*|(?<=playerevent)\\s+(?!extends)[a-zA-Z]\\w*|(?<=playerunitevent)\\s+(?!extends)[a-zA-Z]\\w*|(?<=unitevent)\\s+(?!extends)[a-zA-Z]\\w*|(?<=limitop)\\s+(?!extends)[a-zA-Z]\\w*|(?<=widgetevent)\\s+(?!extends)[a-zA-Z]\\w*|(?<=dialogevent)\\s+(?!extends)[a-zA-Z]\\w*|(?<=unittype)\\s+(?!extends)[a-zA-Z]\\w*|(?<=gamespeed)\\s+(?!extends)[a-zA-Z]\\w*|(?<=gamedifficulty)\\s+(?!extends)[a-zA-Z]\\w*|(?<=gametype)\\s+(?!extends)[a-zA-Z]\\w*|(?<=mapflag)\\s+(?!extends)[a-zA-Z]\\w*|(?<=mapvisibility)\\s+(?!extends)[a-zA-Z]\\w*|(?<=mapsetting)\\s+(?!extends)[a-zA-Z]\\w*|(?<=mapdensity)\\s+(?!extends)[a-zA-Z]\\w*|(?<=mapcontrol)\\s+(?!extends)[a-zA-Z]\\w*|(?<=playerslotstate)\\s+(?!extends)[a-zA-Z]\\w*|(?<=volumegroup)\\s+(?!extends)[a-zA-Z]\\w*|(?<=camerafield)\\s+(?!extends)[a-zA-Z]\\w*|(?<=camerasetup)\\s+(?!extends)[a-zA-Z]\\w*|(?<=playercolor)\\s+(?!extends)[a-zA-Z]\\w*|(?<=placement)\\s+(?!extends)[a-zA-Z]\\w*|(?<=startlocprio)\\s+(?!extends)[a-zA-Z]\\w*|(?<=raritycontrol)\\s+(?!extends)[a-zA-Z]\\w*|(?<=blendmode)\\s+(?!extends)[a-zA-Z]\\w*|(?<=texmapflags)\\s+(?!extends)[a-zA-Z]\\w*|(?<=effect)\\s+(?!extends)[a-zA-Z]\\w*|(?<=effecttype)\\s+(?!extends)[a-zA-Z]\\w*|(?<=weathereffect)\\s+(?!extends)[a-zA-Z]\\w*|(?<=terraindeformation)\\s+(?!extends)[a-zA-Z]\\w*|(?<=fogstate)\\s+(?!extends)[a-zA-Z]\\w*|(?<=fogmodifier)\\s+(?!extends)[a-zA-Z]\\w*|(?<=dialog)\\s+(?!extends)[a-zA-Z]\\w*|(?<=button)\\s+(?!extends)[a-zA-Z]\\w*|(?<=quest)\\s+(?!extends)[a-zA-Z]\\w*|(?<=questitem)\\s+(?!extends)[a-zA-Z]\\w*|(?<=defeatcondition)\\s+(?!extends)[a-zA-Z]\\w*|(?<=timerdialog)\\s+(?!extends)[a-zA-Z]\\w*|(?<=leaderboard)\\s+(?!extends)[a-zA-Z]\\w*|(?<=multiboard)\\s+(?!extends)[a-zA-Z]\\w*|(?<=multiboarditem)\\s+(?!extends)[a-zA-Z]\\w*|(?<=trackable)\\s+(?!extends)[a-zA-Z]\\w*|(?<=gamecache)\\s+(?!extends)[a-zA-Z]\\w*|(?<=version)\\s+(?!extends)[a-zA-Z]\\w*|(?<=itemtype)\\s+(?!extends)[a-zA-Z]\\w*|(?<=texttag)\\s+(?!extends)[a-zA-Z]\\w*|(?<=attacktype)\\s+(?!extends)[a-zA-Z]\\w*|(?<=damagetype)\\s+(?!extends)[a-zA-Z]\\w*|(?<=weapontype)\\s+(?!extends)[a-zA-Z]\\w*|(?<=soundtype)\\s+(?!extends)[a-zA-Z]\\w*|(?<=lightning)\\s+(?!extends)[a-zA-Z]\\w*|(?<=pathingtype)\\s+(?!extends)[a-zA-Z]\\w*|(?<=image)\\s+(?!extends)[a-zA-Z]\\w*|(?<=ubersplat)\\s+(?!extends)[a-zA-Z]\\w*|(?<=hashtable)\\s+(?!extends)[a-zA-Z]\\w*


  // ast file
  class {
  constructor(document) {
    this.NodeType = {
      Comment,
      Macro, // 宏
      Type,
      Globals,
      Function, // 包含native方法
    }
    this.nodes = []
  }
  parse(content) {
    if (!content || content.trim() == "") return [];
    let lines = this.toLine(content)
    let functing = false; // 記錄是否開始function block
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (/^\s*function/.test(line.content)) {
        if (functing) {
          this.nodes.push(this.parseFunctionHeade(line));
        } else {
          functing = true;
        }
      }
    }
  }
  /**
   * @param {string} content 
   */
  toLine(content) {
    if (!content || content.trim() == "") return [];
    let contents = content.split("\n");
    return contents.map((item, index) => {
      let tlContent = item.trimLeft();
      return {
        content: item,
        line: index + 1,
        isEmpty: tlContent == "",
        firstCharacterIndex: item.length - tlContent.length - 1,
        /**
         * 
         * @param {string} str 
         */
        startWith(str) {
          if (this.firstCharacterIndex < 0) return false;
          if (str.trimLeft().length == 0) return true;
          return item.substr(this.firstCharacterIndex).startsWith(str)
        },
      }
    })
  }


  /**
   * 解析方法信息
   * @param {{content:string,line:number,isEmpty:boolean,firstCharacterIndex:number,startWith:function}} line 
   * @returns {{ line: number, name: string, nameRange: { start: number, end: number }, parameters: {type:string,name:string}[], returnType:  string}}
   */
  parseFunctionHeade(line) {
    if (!line || line.isEmpty) return null;

    let isConstant = /^\s*constant/.test(line.content)
    let isNative = /^\s*(native|constant\s+native)/.test(line.content)

    // 獲取方法名稱
    const nameResult = line.content.match(/(?<=^\s*(function|native|constant\s+native)\s+)[a-zA-Z]\w+/);
    let name = nameResult ? nameResult.shift() : null;
    if (!name);

    // 獲取方法參數 若空串或nothing 設置為空數組而不是null
    let argsStringResult = text.match(/(?<=takes\s+).+?(?=\s+returns)/);
    let argsString = argsStringResult ? argsStringResult.shift() : "nothing";
    let args = argsString == "nothing" ? [] : argsString.split(",").map(s => {
      // 無法接受只有類而沒有類名 亦不能接受只有類名而無類 如 takes integer , u1 returns
      let ptypeResult = s.match(ParamenterType.join("|"));
      if (!ptypeResult) return null;
      let ptype = ptypeResult ? ptypeResult.shift() : null;
      if (!ptype) return null;
      let pnameResult = s.match(`(?<=${ptype}\\s+)[a-z]\\w*`);
      if (!pnameResult) return null;
      let pname = pnameResult.shift();
      if (!pname) return null;
      return { name: pname, type: ptype };
    }).filter(s => s)

    // 獲取方法返回值 空串或nothing 設置為null
    let returnTypeResult = text.match(/(?<=returns\s+)[a-z]+/);
    let returnType = returnTypeResult ? returnTypeResult.shift() : "nothing";
    returnType = returnType == "nothing" ? null : returnType;

    return {
      line: line.line,
      closeLine: line.line,
      name: name,
      nameRange: {
        start: line.content.indexOf(name),
        end: this.start + name.length
      },
      isConstant,
      isNative,
      parameters: args,
      returnType: returnType,
    }
  }



}

var jass = {
  NodeType = {
    Comment,
    Macro, // 宏
    Type,
    Globals,
    Function, // 包含native方法
  },


  /**
   * jass文檔節點抽象表示
   */
  nodes: []

}


vscode.languages.registerCompletionItemProvider("jass", {
  provideCompletionItems(document, position, token, context) {
  },
  resolveCompletionItem(item, token) {
    return item;
  }
}, characters.l, characters.u)
    

// type
|(?<=type)\\s+[a-zA-Z]+|(?<=extends)\\s+[a-zA-Z]+|(?<=returns)\\s+[a-zA-Z]+|(?<=local)\\s+[a-zA-Z]+|(?<=constant)\\s+[a-zA-Z]+|(?<=takes)\\s+[a-zA-Z]+|(?<=,)\\s*[a-zA-Z]+\\s*(?=[a-zA-Z])

NewType